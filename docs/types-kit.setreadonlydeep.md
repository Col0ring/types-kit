<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [types-kit](./types-kit.md) &gt; [SetReadonlyDeep](./types-kit.setreadonlydeep.md)

## SetReadonlyDeep type

Make some properties (includes deep properties) in T readonly (add readonly decorator)..

<b>Signature:</b>

```typescript
export type SetReadonlyDeep<T, K extends DeepKeys<T>> = IsNever<
  Extract<K, Keys<T>>
> extends true
  ? // for tuple when not match the first level properties
    {
      [P in keyof T]: T[P] extends infer V
        ? V extends V
          ? IsObject<V> extends true
            ? SetReadonlyDeep<
                V,
                // distributed condition type
                K extends `${infer Head}.${infer Tail}`
                  ? P extends Head
                    ? Extract<
                        Tail extends Tail
                          ? `${P}.${Tail}` extends K
                            ? Tail
                            : never
                          : never,
                        DeepKeys<V>
                      >
                    : never
                  : never
              >
            : V
          : never
        : never
    }
  : Simplify<
      {
        readonly [P in keyof T as If<
          And<[IsExtends<P, Keys<T>>, IsExtends<P, K>]>,
          P,
          never
        >]: T[P] extends infer V
          ? V extends V
            ? IsObject<V> extends true
              ? SetReadonlyDeep<
                  V,
                  // distributed condition type
                  K extends `${infer Head}.${infer Tail}`
                    ? P extends Head
                      ? Extract<
                          Tail extends Tail
                            ? `${P}.${Tail}` extends K
                              ? Tail
                              : never
                            : never,
                          DeepKeys<V>
                        >
                      : never
                    : never
                >
              : V
            : never
          : never
      } & {
        [P in keyof T as If<
          And<[IsExtends<P, Keys<T>>, Not<IsExtends<P, K>>]>,
          P,
          never
        >]: T[P] extends infer V
          ? V extends V
            ? IsObject<V> extends true
              ? SetReadonlyDeep<
                  V,
                  // distributed condition type
                  K extends `${infer Head}.${infer Tail}`
                    ? P extends Head
                      ? Extract<
                          Tail extends Tail
                            ? `${P}.${Tail}` extends K
                              ? Tail
                              : never
                            : never,
                          DeepKeys<V>
                        >
                      : never
                    : never
                >
              : V
            : never
          : never
      }
    >
```
<b>References:</b> [DeepKeys](./types-kit.deepkeys.md)<!-- -->, [IsNever](./types-kit.isnever.md)<!-- -->, [Keys](./types-kit.keys.md)<!-- -->, [IsObject](./types-kit.isobject.md)<!-- -->, [SetReadonlyDeep](./types-kit.setreadonlydeep.md)<!-- -->, [Simplify](./types-kit.simplify.md)<!-- -->, [If](./types-kit.if.md)<!-- -->, [And](./types-kit.and.md)<!-- -->, [IsExtends](./types-kit.isextends.md)<!-- -->, [Not](./types-kit.not.md)

## Example


```ts
interface Props {
       a: {
         b?: number
         readonly c: {
           d: number
         }
       }
       e: number
     }
     // Expect: {
     //   readonly a: {
     //     b?: number | undefined
     //     readonly c: {
     //       readonly d: number
     //     }
     //   }
     //   readonly e: number
     // }
     type NewProps = SetReadonlyDeep<Props, 'e' | 'a' | 'a.c.d'>
```

